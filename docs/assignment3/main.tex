\documentclass{article}
\usepackage{graphicx}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}
\usepackage[letterpaper,top=2cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}
\usepackage{graphicx}
\usepackage{indentfirst}
\usepackage{tcolorbox}
\usepackage{xcolor}
\usepackage{amsmath}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\usepackage{listings}
\lstset{language=C++}
\lstset{breaklines=true}
\lstset{
    literate={"}{{\texttt{"}}}1
             {'}{{\texttt{'}}}1
             {~}{{\texttt{~}}}1
             { }{{\ }}1
}
\lstdefinestyle{code}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=t,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    language=C++
}

\lstdefinestyle{output}{
    backgroundcolor=\color{black!5},
    basicstyle=\ttfamily\small,
    breaklines=true,
    showstringspaces=false,
    frame=single,
    rulecolor=\color{black!20},
    numbers=none,
    captionpos=t,
    language=bash
}

\renewcommand{\lstlistingname}{Code block}


\newcounter{exercise}
\newenvironment{exr}[1]{%
    \refstepcounter{exercise}
    \begin{tcolorbox}[colback=blue!5!white, colframe=blue!75!black, title=Exercise \theexercise]
    \textbf{Instructions:} #1
    \end{tcolorbox}
    \vspace{1em}
}{}

\patchcmd{\thebibliography}{\section*{\refname}}{}{}{}

\title{
    TAC-HEP GPU Programming Training Module: Assignment 3
}

\author{Roy F. Cruz}

\begin{document}

\date{October 26, 2025}
\maketitle

The GitHub repository that hosts this code can be accessed via the following link: \href{https://github.com/roy-cruz/TAC-HEP_GPU-Course_Assignments/tree/master}{link}

\begin{exr}{
    \begin{itemize}
        \item Calculate the dot product of two vectors of size N using \texttt{atomicAdd()}.
        \item Start from file \texttt{dot\_product.cu}.
    \end{itemize}
    }
\end{exr}

In this code, we take the dot product of two arrays. Firstly, it allocates the required memory in both the host and device, and passes the arrays \texttt{A} and \texttt{B} (all elements initialized to 1) and the result \texttt{int} variable C (initialized to 0) from host to device memory. Then the kernel \texttt{dot\_product} is called which computes the dot product:

\begin{align*}
    C = \vec A \cdot \vec B = \sum_{i}A_iB_i
\end{align*}

\noindent In the kernel, each thread computes a single term in the above sum and adds it to \texttt{C}. This summation is done using \texttt{atomicAdd} in order to avoid a race condition. The result of these operations is then passed to the host device and the result is printed.

\lstinputlisting[caption={\texttt{swap\_vectors.cu}}, style=code]{../../assignment3/dot_product.cu}

\begin{lstlisting}[style=output]
[rcruzcan@cmsgpu01 assignment3]$ nvcc dot_product.cu -o ./objs/dot_product 
[rcruzcan@cmsgpu01 assignment3]$ ./objs/dot_product 
A (first 10 elements out of 256):
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
B (first 10 elements out of 256):
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 

Dot Product: 256
\end{lstlisting}


% ------------------------------------------------------------------------


\begin{exr}{
    \begin{itemize}
        \item Apply a 2-D stencil of radius \texttt{RADIUS} on a 2-D square matrix of size \texttt{DSIZE * DSIZE}. 
        \item Make use of shared memory. Remember to also load into shared memory the halo elements of the matrix.
        \item Start from file \texttt{stencil\_2d.cu}.
    \end{itemize}   
}\end{exr}

In this exercise, a 2D stencil of radius 2 is applied to all of the elements of a matrix. The input matrix \texttt{in}, which has dimensions \texttt{N*N}, but is padded so that its size is \texttt{(N+2*RADIUS)*(N+2*RADIUS)}, is first initialized so that all of its elements are 1. Then, after passing the matrix from host to device memory, the kernel \texttt{stencil\_2d} is called which transforms each of the elements of the matrix as follows (where $C$ is output matrix and $A$ is the input matrix):

\begin{align*}
    C_{ij} = \sum_{k=-m}^m \sum_{l=-n}^n A_{i+k,j+l},
\end{align*}

\noindent where $m=n=2$, and indices $k,l < 0$ and $k,l \geq$ \texttt{RADIUS} correspond to the padding elements of the matrix.

This implementation uses shared memory to reduce global memory traffic. Each thread loads its own input element into shared memory, while additional threads at the block boundaries also load the halo elements necessary for the stencil operation in both the x- and y-directions. The call to \texttt{\_\_syncthreads()} ensures that all threads in the block have completed caching the needed matrix elements into shared memory. Once synchronized, each thread in the block computes its corresponding output.

\lstinputlisting[caption={\ttfamily{add\_matrix.cu}}, style=code]{../../assignment3/stencil_2d.cu}

\begin{lstlisting}[style=output]
[rcruzcan@cmsgpu01 assignment3]$ nvcc stencil_2d.cu -o objs/stencil_2d 
[rcruzcan@cmsgpu01 assignment3]$ ./objs/stencil_2d 
Success!
\end{lstlisting}

\end{document}